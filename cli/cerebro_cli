#!/usr/bin/python
# Copyright 2016 Cerebro Data, Inc. All Rights Reserved.

import getpass
import json
import os
from os.path import expanduser
import pprint
import sys

from optparse import OptionParser, BadOptionError
import requests
from tabulate import tabulate

STATUS_OK = 200
CREATED = 201
BAD_REQUEST = 400
UNAUTHROZIED = 401
NOT_FOUND = 404
CONFLICT = 409
ERROR_INVALID_MEDIA_TYPE = 415

USER = None
TOKEN = None

CEREBRO_CONFIG_DIR = ".cerebro"
CREDENTIALS_FILE = "credentials.json"
CONFIGS_FILE = "configs.json"

# Remap 'input' to 'raw_input' for python 2.x
try:
  input = raw_input
except NameError:
  pass

#
# General utilities
#
def error(msg):
  print("cerebro_cli error: " + msg)
  sys.exit(1)

# Reads a config file, returning the json object. Returns None if the
# config file does not exist.
def read_config_file(file_name, error_msg):
  env_home = expanduser('~')
  if env_home is None:
    return
  file_path = env_home + "/" + CEREBRO_CONFIG_DIR + "/" + file_name
  if not os.path.isfile(file_path):
    return
  with open(file_path) as data_file:
    try:
      return json.load(data_file)
    except (OSError, IOError) as ex:
      error(error_msg + ": " + str(ex))

# Writes a config file to 'fil'
def write_config_file(fil, data):
  env_home = expanduser("~")
  if env_home is None:
    error("user home directory is not set. Cannot persist file.")
  file_path = env_home + "/" + CEREBRO_CONFIG_DIR + "/" + fil
  if not os.path.exists(env_home + "/" + CEREBRO_CONFIG_DIR):
    os.makedirs(env_home + "/" + CEREBRO_CONFIG_DIR)
  try:
    with open(file_path, 'w+') as out:
      json.dump(data, out)
    print("Persisted config file to: " + file_path)
  except (OSError, IOError) as ex:
    error("login: could not persist config file.\n" + str(ex))

def print_usage():
  print("usage: cerebro_cli [options] <command> <subcommand> [parameters]")
  print('''To see help text, you can run:

  cerebro_cli commands
  cerebro_cli <command> help
  cerebro_cli <command> <subcommand> help''')

# Creates a json request with user/token populated.
def create_request():
  data = {}
  data["user"] = USER
  data["token"] = TOKEN
  return data

# Returns true if the response's status code is a successful one.
def is_ok(response):
  return response.status_code >= 200 and response.status_code < 300

# TODO: this will return the server's (jersey) default error handling when the
# request is malformed (e.g. json missing fields). This is hard for the user.
# Fix this.
def handle_error(response, error_msg):
  error_text = "\n" + response.text
  if ("Content-Type" in response.headers) and\
      ("text/html" in response.headers["Content-Type"]):
    error_text = ""
  if response.status_code == UNAUTHROZIED:
    error(error_msg + ": unauthorized access." + error_text)
  error(error_msg + ": " + response.reason + "." + error_text)

# Calls the server endpoint for url and returns the response as json.
def get_request(url, error_msg):
  response = requests.get(url)
  if is_ok(response):
    return response.json()
  handle_error(response, error_msg)

# Issues a delete request to the server endpoint for url and returns the response.
def delete_request(url, error_msg):
  response = requests.delete(url)
  if is_ok(response):
    return response.json()
  handle_error(response, error_msg)

# Issues a put request. If data is None, will just populate it with the
# authentication credentials.
def put_request(url, error_msg, data):
  headers = {'content-type': 'application/json'}
  response = requests.put(url, data, headers=headers)
  if is_ok(response):
    return response
  handle_error(response, error_msg)

# Issues a post request. If data is None, will just populate it with the
# authentication credentials.
def post_request(url, error_msg, request=None):
  if request is None:
    request = create_request()
  data = json.dumps(request)
  headers = {'content-type': 'application/json'}
  response = requests.post(url, data, headers=headers)
  if is_ok(response):
    return response
  handle_error(response, error_msg)

#
# Token config utilities
#
def init_user_token(options):
  global USER
  global TOKEN

  # First check if arguments were passed in the command line.
  if options is not None:
    if options.user != "":
      USER = options.user
    if options.token != "":
      TOKEN = options.token
    if USER is not None:
      if TOKEN is None:
        error("Cannot set --login_user without setting --login_token.")
      return

  # Try to get the credentials from the environment.
  env_user = os.environ.get('CEREBRO_USER')
  env_token = os.environ.get('CEREBRO_TOKEN')
  if env_user is None and env_token is not None:
    error("If environment CEREBRO_TOKEN is set, CEREBRO_USER must be set.")
  if env_user is not None and env_token is None:
    error("If environment CEREBRO_USER is set, CEREBRO_TOKEN must be set.")
  if env_user is not None:
    USER = env_user
    TOKEN = env_token
    return

  # Try to get the credentials from config file.
  data = read_config_file(CREDENTIALS_FILE, "Invalid credentials file")
  if data is None:
    return
  if not "userName" in data:
    error("Credentials file does not contain 'user'")
  if not "token" in data:
    error("Credentials file does not contain 'token'")
  USER = data['userName']
  TOKEN = data['token']

def ensure_token_set():
  if USER is None or TOKEN is None:
    msg = '''Could not get user credentials. Run 'cerebro_cli login' to generate a token.

cerebro_cli will look in a these places, in this order for user tokens:
  1. commandline arguments to the cli. run 'cerebro_cli --help' for details.
  2. envirnoment variables: CEREBRO_USER and CEREBRO_TOKEN.
  3. config file in your home directory at: ~/.cerebro/'''
    error(msg)

def handle_help():
  print('''\
cerebro_cli provides an interface to manager the entire cerebro deployment. This includes
tasks such as viewing and modifying users, access tokens, access policies as well as
deploying and terminating clusters.

To login for the first time:
  $ cerebro_cli login
To see the list of available commands:
  $ cerebro_cli commands
To see the details of each command:
  $ cerebro_cli <command> help
''')
#
# Argument parsing utilities.
#

# Parses parameter in args[2...). The result is a dictionary with the key
# value pairs.
def parse_arguments(args, error_msg, required_args, first_idx=2):
  params = {}
  i = first_idx
  while i < len(args):
    if not args[i].startswith("--"):
      error(error_msg + ": invalid argument: " + args[i] +\
        ". Arguments should being with --")
    if i == len(args) -1 or args[i + 1].startswith("--"):
      params[args[i][2:]] = ""
      i += 1
    else:
      params[args[i][2:]] = args[i + 1]
      i += 2
  if required_args is not None:
    ensure_parameters(params, required_args, error_msg)
  return params

# Returns the value of parameter for 'key'. This also removes the key from
# params.
def get_parameter(params, key, optional=False):
  if not key in params:
    if optional:
      return None
    # Should have been verified by ensure_parameters
    assert False
  val = params[key]
  del params[key]
  return val

# Ensures that all of the keys in args is in params.
def ensure_parameters(params, args, error_msg):
  missing = []
  for key in args:
    if key not in params:
      missing.append("--" + key)
  if len(missing) == 0:
    return
  elif len(missing) == 1:
    error(error_msg + ": missing required parameter: " + missing[0])
  else:
    error(error_msg + ": missing required parameters: " + str(missing))

# Filters out key from objects. Objects is an array of json objects. If keep is
# true, keys is a white list, otherwise it is a black list.
def filter_json_keys(objects, keys, keep=True):
  for obj in objects:
    removed_keys = []
    for key in obj:
      if key not in keys and keep:
        removed_keys.append(key)
      elif key in keys and not keep:
        removed_keys.append(key)
    for key in removed_keys:
      del obj[key]
  return objects

#
# ACL commands
#
def get_acls_commands():
  return '''
valid subcommands are:
  grant
  list
  revoke
'''

def print_acls_help():
  print('''acls subcommands:
    acls <grant|revoke>: Grants or revokes ACLs for a particular user.
        --user: ID/username to grant or revoke ACLs to.
        --acls: comma separate list of ACLs to grant or revoke.
        example:
          cerebro_cli acls grant --user=123 --acls=LIST_CLUSTERS,ADD_USER
    acls list: Lists all the acls available.''')

def handle_acls_list(api_url):
  acls = get_request(api_url + "acls", "unable to list acls")
  for acl in acls:
    print(acl)

def handle_grant_revoke(api_url, args, grant):
  params = parse_arguments(args, 'acls grant/revoke', required_args=['user', 'acls'])
  user = get_parameter(params, 'user')
  acls = get_parameter(params, 'acls')
  if len(params) != 0:
    print_acls_help()
    error("acls: invalid argument(s): " + str(params.keys()))

  data = create_request()
  if grant:
    data["grants"] = acls
  else:
    data["revokes"] = acls

  post_request(api_url + "acls/" + user, "unable to update acls", data)
  print("Updated ACLs for user: " + user)

def handle_acls(api_url, args):
  if len(args) == 1:
    error("usage: cerebro_cli [options] acls <subcommand> [parameters]\n" +\
        get_acls_commands())

  cmd = args[1]
  if cmd == "help":
    print_acls_help()
    return

  if cmd == "grant":
    handle_grant_revoke(api_url, args, grant=True)
  elif cmd == "list":
    handle_acls_list(api_url)
  elif cmd == "revoke":
    handle_grant_revoke(api_url, args, grant=False)
  else:
    error("acls: invalid subcommand '" + cmd + "'.\n" + get_acls_commands())

#
# Commands
#
def get_commands():
  return '''
acls
clusters
commands
configure
environments
login
status
system
tokens
users
'''

#
# Cluster commands
#
def get_clusters_commands():
  return '''
valid subcommands are:
  create
  delete
  endpoints
  list
  restart
  status
  update
'''

def print_clusters_help():
  print('''clusters subcommands:
    clusters create: Create a new cluster.
        --name: Name of the cluster to create.
        --numNodes: Number of nodes in this cluster.

        --environmentid: [Optional] Id of the environmnet for this cluster.
            Either environmentid or existingCluster must be set.
        --existingCluster: [Optional] Name of existing kubernetes cluster.
            Either environmentid or existingCluster must be set.

        --type: Type of cluster to create.
        --desc: [Optional] Description for this cluster
        --tags: [Optional] Commma separated list of tags for the cluster.
        --catalogClusterId: [Optional] clusterid of the catalog cluster. Must be specified
            to a running catalog cluster if this is a data access cluster.
    clusters delete: Deletes a cluster. This starts tearing down the cluster.
        --clusterid: ID of the cluster to delete.
    clusters endpoints: Returns the endpoints of this cluster.
        --clusterid: ID of the cluster.
    clusters list: Returns the clusters in the system.
        --user: [Optional] Return only clusters by this user.
        --tags: [Optional] Return only clusters that match all tags (comma separated).
        --clusterid: [Optional] Return only information for this cluster.
        --detail: [Optional, Default=False] Returns all the fields for this cluster.
        --json: [Optional, Default=False] Outputs the cluster status as json.
    clusters restart: Restarts the cluster. By default, this just restarts the services.
        --clusterid: ID of the cluster.
        --restartMachines: If set, also restarts the cluster machines.
    clusters status: Returns the status of this cluster.
        --clusterid: ID of the cluster.'
        --detail: [Optional, Default=False] Returns details for this status.
    clusters update: Update an existing cluster.
        --clusterid: ID of the cluster to delete.
        --name [Optional]: New name of the deploymnet.
        --numNodes [Optional]: New number of nodes for this cluster.
        --desc: [Optional] New description for this cluster.
        --tags: [Optional] Commma separated list of tags for the cluster.''')

# The keys that should be showed by default (if --detail is not specified)
CLUSTER_LIST_DEFAULT_KEYS = { 'description', 'id', 'name',
    'numNodes', 'numRunningServices', 'owner', 'statusCode', 'statusMessage', 'type' }

# Keys that really don't print well in tabular form.
CLUSTER_LIST_REMOVED_KEYS = { 'clusterStatus', 'services', 'statuses' }

def handle_clusters_list(api_url, args):
  params = parse_arguments(args, 'clusters list', [])
  user_id = get_parameter(params, 'user', optional=True)
  tags = get_parameter(params, 'tags', optional=True)
  clusterid = get_parameter(params, 'clusterid', optional=True)
  detail = get_parameter(params, 'detail', optional=True)
  as_json = get_parameter(params, 'json', optional=True)

  if len(params) != 0:
    print_clusters_help()
    error("clusters list: invalid argument(s): " + str(params.keys()))

  request = create_request()
  url = api_url + 'clusters'
  if clusterid:
    url = url + '/' + clusterid
  else:
    request['userId'] = user_id
    request['matchAllTags'] = tags

  response = post_request(url, 'unable to list clusters', request)
  result_json = response.json()
  if as_json is not None:
    print(json.dumps(result_json, indent=4))
    return

  if clusterid:
    clusters = [ result_json ]
  else:
    clusters = result_json

  if detail is None:
    # Not viewing detailed view, filter out the detail only fields
    clusters = filter_json_keys(clusters, CLUSTER_LIST_DEFAULT_KEYS)
  else:
    clusters = filter_json_keys(clusters, CLUSTER_LIST_REMOVED_KEYS, keep=False)

  if not clusters:
    print("No clusters.")
  else:
    print(tabulate(clusters, headers="keys"))

def handle_cluster_create(api_url, args):
  params = parse_arguments(args, 'clusters create',
      ['name', 'numNodes', 'type'])
  data = create_request()
  data['name'] = get_parameter(params, 'name')
  data['environmentId'] = get_parameter(params, 'environmentid', optional=True)
  data['numNodes'] = get_parameter(params, 'numNodes')
  data['type'] = get_parameter(params, 'type')
  data['description'] = get_parameter(params, 'desc', optional=True)
  data['tags'] = get_parameter(params, 'tags', optional=True)
  data['externalClusterName'] = get_parameter(params, 'existingCluster', optional=True)

  catalog_cluster_id = get_parameter(params, 'catalogClusterId', optional=True)
  if catalog_cluster_id:
    data['catalogClusterId'] = catalog_cluster_id

  if len(params) != 0:
    print_clusters_help()
    error("clusters create: invalid argument(s): " + str(params.keys()))

  response = put_request(api_url + "clusters", 'unable to create cluster',
                         json.dumps(data))
  created_id = response.text
  print("Created cluster '" + data['name'] + "' (id=" + created_id + ").")

def handle_cluster_delete(api_url, args):
  params = parse_arguments(args, "clusters delete", ['clusterid'])
  clusterid = get_parameter(params, 'clusterid')
  if len(params) != 0:
    print_clusters_help()
    error("clusters delete: invalid argument(s): " + str(params.keys()))

  post_request(api_url + "clusters/" + clusterid + "/delete",
      'unable to delete cluster')
  print("Deleted cluster: " + clusterid + ".")

def handle_cluster_endpoints(api_url, args):
  params = parse_arguments(args, 'cluster endpoints', ['clusterid'])
  clusterid = get_parameter(params, 'clusterid')
  if len(params) != 0:
    print_clusters_help()
    error("clusters endpoints: invalid argument(s): " + str(params.keys()))
  return post_request(api_url + "clusters/" + clusterid + "/endpoints",
                      'unable to get cluster endpoints').json()

def handle_clusters_restart(api_url, args):
  params = parse_arguments(args, 'cluster restart', ['clusterid'])
  clusterid = get_parameter(params, 'clusterid')
  restart_machines = get_parameter(params, 'restartMachines', optional=True)
  if len(params) != 0:
    print_clusters_help()
    error("clusters restart: invalid argument(s): " + str(params.keys()))

  data = create_request()
  if restart_machines:
    data['restartMachines'] = restart_machines
  post_request(api_url + "clusters/" + clusterid + "/restart",
      'unable to get restart cluster')
  print('Restarted cluster: ' + clusterid + '.')

def handle_cluster_status(api_url, args):
  params = parse_arguments(args, 'cluster status', ['clusterid'])
  clusterid = get_parameter(params, 'clusterid')
  detail = get_parameter(params, 'detail', optional=True)

  if len(params) != 0:
    print_clusters_help()
    error("clusters status: invalid argument(s): " + str(params.keys()))

  result = post_request(api_url + "clusters/" + clusterid + "/status",
      'unable to get cluster status').json()

  if detail is None:
    return result['code']
  else:
    return json.dumps(result, indent=4)

def handle_cluster_update(api_url, args):
  params = parse_arguments(args, 'clusters update', ['clusterid'])
  clusterid = get_parameter(params, 'clusterid')
  name = get_parameter(params, 'name', optional=True)
  num_nodes = get_parameter(params, 'numNodes', optional=True)
  desc = get_parameter(params, 'desc', optional=True)
  tags = get_parameter(params, 'tags', optional=True)
  if len(params) != 0:
    print_clusters_help()
    error("clusters update: invalid argument(s): " + str(params.keys()))

  data = create_request()
  if name is not None:
    data['name'] = name
  if numNodes is not None:
    data['numNodes'] = numNodes
  if desc is not None:
    data['description'] = desc
  if tags is not None:
    data['tags'] = tags
  response = post_request(api_url + "clusters/" + clusterid + "/update",
      'unable to update cluster', data)
  print("Updated cluster")

def handle_clusters(api_url, args):
  if len(args) == 1:
    error("usage: cerebro_cli [options] clusters <subcommand> [parameters]\n" +\
        get_clusters_commands())

  cmd = args[1]
  if cmd == "help":
    print_clusters_help()
    return

  if cmd == "create":
    handle_cluster_create(api_url, args)
  elif cmd == "delete":
    handle_cluster_delete(api_url, args)
  elif cmd == "endpoints":
    result = handle_cluster_endpoints(api_url, args)
    if 'endpoints' in result:
      print(json.dumps(result['endpoints'], indent=4))
    else:
      print('Cluster does not have any active endpoints.')
  elif cmd == "list":
    handle_clusters_list(api_url, args)
  elif cmd == "restart":
    handle_clusters_restart(api_url, args)
  elif cmd == "status":
    print(handle_cluster_status(api_url, args))
  elif cmd == "update":
    handle_cluster_update(api_url, args)
  else:
    error("clusters: invalid subcommand '" + cmd + "'.\n" + get_clusters_commands())

#
# Environments commands
#
def get_environment_commands():
  return '''
valid subcommands are:
  create
  delete
  list
  update
'''

def print_environments_help():
  print('''environments subcommands:
    environments create: Create a new environment.
        --name: Name of the environment to create.
        --provider: Provider for this environment [AWS|LOCAL]
        --tags: [Optional] Commma separated list of tags for the environment.
        --desc: [Optional] Description for this environment
        --inheritConfigs: [Optional] If true, inherit the settings from the
            DeploymentManager environment. For example, using the access credentials,
            vpc settings, etc that the DeploymentManager is running on.

        --localMasterHostPort: Host:Port of the kubernetes master. Required if provider
            is LOCAL.

        --awsAccessKey: [Optional] Access key to use for this environment. If this is
            specified, AWS_SECRET_ACCESS_KEY must be set in the environment.
        --iamRole: [Optional] IAM role to use for instances spun up in this environment.

        --awsAZ: [Optional] Availability zone for this environment. Defaults to the
            environment the DeploymentManager is running in.
        --vpcId: [Optional] VPC to use for this environment.
        --vpcCidrBase: [Optional] VPC CIDR base. Must be specified if vpcId is specified.
        --subnetId: [Optional] Subnet to use for this environment.
        --securityGroup: [Optional] Security group to run in.

        --sshKeyName: [Optional] Optional key name. Machines provisioned in this
            environment reachable using this key.
        --disableSsh: [Optional] If true, disables ssh on the provisioned machines.

    environments delete: Deletes an environment.
        --environmentid: ID of the environment to delete.
    environments list: Returns the environments in the system.
        --user: [Optional] Return only environments by this user.'
        --tags: [Optional] Return only environments that match all tags (comma separated).
        --detail: [Optional, Default=False] Returns all the fields for this environment.
    environments update: Update an existing environment.
        --environmentid: ID of the environment to delete.
        --name [Optional]: New name of the environment.
        --desc: [Optional] New description for this environment.
        --tags: [Optional] Commma separated list of tags for the environment.''')

ENVS_LIST_DEFAULT_KEYS = { 'awsAccessKey', 'description', 'id', 'iamRole', 'name',
    'owner', 'provider', 'tags', 'vpcId'}

def handle_environments_list(api_url, args):
  params = parse_arguments(args, 'environments list', [])
  user_id = get_parameter(params, 'user', optional=True)
  tags = get_parameter(params, 'tags', optional=True)
  detail = get_parameter(params, 'detail', optional=True)

  if len(params) != 0:
    print_environments_help()
    error("environments list: invalid argument(s): " + str(params.keys()))

  request = create_request()
  request['userId'] = user_id
  request['matchAllTags'] = tags
  response = post_request(api_url + "environments", 'unable to list environments',
      request)
  envs = response.json()

  if detail is None:
    # Not viewing detailed view, filter out the detail only fields
    envs = filter_json_keys(envs, ENVS_LIST_DEFAULT_KEYS)
  return envs

# We don't want to specify the secrets via commandline.
def create_environment(api_url, args):
  params = parse_arguments(args, 'environments create', ['name', 'provider'])
  name = get_parameter(params, 'name')
  provider = get_parameter(params, 'provider').upper()
  desc = get_parameter(params, 'desc', optional=True)
  inherit_configs = get_parameter(params, 'inheritConfigs', optional=True)
  tags = get_parameter(params, 'tags', optional=True)
  iam_role = get_parameter(params, 'iamRole', optional=True)
  vpc_id = get_parameter(params, 'vpcId', optional=True)
  vpc_cidr_base = get_parameter(params, 'vpcCidrBase', optional=True)
  subnet_id = get_parameter(params, 'subnetId', optional=True)
  security_group = get_parameter(params, 'securityGroup', optional=True)
  ssh_key_name = get_parameter(params, 'sshKeyName', optional=True)
  disable_ssh = get_parameter(params, 'disableSsh', optional=True)

  aws_az = get_parameter(params, 'awsAZ', optional=True)
  aws_access_key = get_parameter(params, 'awsAccessKey', optional=True)
  aws_secret_key = None

  local_master_url = get_parameter(params, 'localMasterHostPort', optional=True)
  if len(params) != 0:
    print_environments_help()
    error("environments create: invalid argument(s): " + str(params.keys()))

  VALID_PROVIDERS = ['AWS', 'LOCAL']
  if provider not in VALID_PROVIDERS:
    error("environments create: invalid provider. Must be one of: " +
        str(VALID_PROVIDERS))

  if aws_access_key is not None:
    aws_secret_key = os.getenv('AWS_SECRET_ACCESS_KEY')
    if aws_secret_key is None:
      error("environments create: If awsAccessKey is set, " + \
          "AWS_SECRET_ACCESS_KEY must be set in the environment.")

  data = create_request()
  data['name'] = name
  data['provider'] = provider
  data['inheritConfigs'] = inherit_configs
  data['description'] = desc
  data['tags'] = tags

  if provider == 'LOCAL':
    data['localMasterHostPort'] = local_master_url
  elif provider == 'AWS':
    data['awsAZ'] = aws_az
    data['awsAccessKey'] = aws_access_key
    data['awsSecretKey'] = aws_secret_key
    data['iamRole'] = iam_role
    data['vpcId'] = vpc_id
    data['vpcCidrBase'] = vpc_cidr_base
    data['subnetId'] = subnet_id
    data['securityGroup'] = security_group
    data['sshKeyName'] = ssh_key_name
    data['disableSsh'] = disable_ssh
  response = put_request(api_url + "environments", 'unable to create environment',
                         json.dumps(data))
  created_id = response.text
  print("Created environment '" + name + "' (id=" + created_id + ").")

def delete_environment(api_url, args):
  params = parse_arguments(args, "environments delete", ['environmentid'])
  envid = get_parameter(params, 'environmentid')
  if len(params) != 0:
    print_environments_help()
    error("environments delete: invalid argument(s): " + str(params.keys()))

  post_request(api_url + "environments/" + envid + "/delete",
      'unable to delete environment')
  print("Deleted environment: " + envid + ".")

def update_environment(api_url, args):
  params = parse_arguments(args, 'environments update', ['environmentid'])
  envid = get_parameter(params, 'environmentid')
  name = get_parameter(params, 'name', optional=True)
  desc = get_parameter(params, 'desc', optional=True)
  tags = get_parameter(params, 'tags', optional=True)
  if len(params) != 0:
    print_environments_help()
    error("environment update: invalid argument(s): " + str(params.keys()))

  data = create_request()
  if name is not None:
    data['name'] = name
  if desc is not None:
    data['description'] = desc
  if tags is not None:
    data['tags'] = tags
  response = post_request(api_url + "environments/" + envid + "/update",
      'unable to update environment', data)
  print("Updated environment'")

def handle_environments(api_url, args):
  if len(args) == 1:
    error("usage: cerebro_cli [options] environments <subcommand> [parameters]\n" +\
        get_environment_commands())

  cmd = args[1]
  if cmd == "help":
    print_environments_help()
    return

  if cmd == "create":
    create_environment(api_url, args)
  elif cmd == "delete":
    delete_environment(api_url, args)
  elif cmd == "list":
    environments_json = handle_environments_list(api_url, args)
    if not environments_json:
      print("No environments.")
    else:
      print(tabulate(environments_json, headers="keys"))
  elif cmd == "update":
    update_environment(api_url, args)
  else:
    error("environments: invalid subcommand '" + cmd + "'.\n" +
        get_environment_commands())

#
# Catalog commands
#
def get_catalog_commands():
  return '''
valid subcommands are:
  create-dataset
  delete-dataset
  describe
  grant-access
  list
  permissions
  revoke-access
  status
'''

def print_catalog_help():
  print('''
These commands provide a way to interact with a Cerebro catalog from the CLI. A
Cerebro install can support multiple catalogs. You can specify the catalog endpoint
either with the --catalog-hostport option to the cli, or by configuring it it in
~/.cerebro/configs.json.

    catalog status: Returns the status of this catalog service.

    catalog list: Lists the datasets in the catalog.
        --db: [Optional] The database to query. If not set, set to 'default'
        --filter: [Optional] Filter of catalog object entries that should be
             return. For example 'logs*' returns all tables that begin with 'logs'.
        --detail: [Optional, Default=False] Returns all the fields.

    catalog describe: Describes a datasets in the catalog.
        --db: [Optional] The database to query. If not set, set to 'default'
        --dataset [Required] Name of the dataset.

    catalog create-dataset: Creates a new dataset in this catalog.
        --name: [Optional] Name of the new dataset.
        --db: [Optional] Database to create the dataset in.

        --base_dataset: [Optional] For dervied datasets (i.e. views) the base for this new dataset.
        --projection: [Optional] Comma-separated list of columns to project from the base dataset.
        --filter: [Optional] SQL formatted filters that should be applied to the base dataset.

        --hiveql: [Optional] HiveQL compatible 'CREATE TABLE' or 'CREATE VIEW' ddl.

    catalog delete-dataset: Deletes a dataset from this catalog.
        --dataset: [Required] Name of the new dataset.
        --db: [Optional] Database this dataset is in.

    catalog grant-access: Grants access to a dataset.
        --users_groups: [Required] Comma separated list of users or groups to grant access.
        --dataset: [Required] Name of the dataset.
        --db: [Optional] Database containing the dataset.

    catalog revoke-access: Revokes access to a dataset.
        --users_groups: [Required] Comma separated list of users or groups to revoke access.
        --dataset: [Required] Name of the dataset.
        --db: [Optional] Database containing the dataset.

    catalog permissions: Returns the access permissions for this combination of
        user/groups and datasets. Conceptually, this returns the accesses allowed
        for all the combinations of users/groups and datasets. If a user/group
        does not have access, nothing is returned.

        --db: [Optional] The database to query. If not set, set to 'default'
        --filter: [Optional] Filter of catalog object entries that should be
             return. For example 'logs*' returns all tables that begin with 'logs'.

        --users_groups: Users or groups to filter on. If not set, returns the result
             for all users.
        --detail: [Optional, Default=False] Returns all the fields.''')

CATALOG_LIST_DEFAULT_KEYS = { 'database', 'name', 'owner' }
CATALOG_PERMISSIONS_DEFAULT_KEYS = {
    'database', 'name', 'level', 'users/groups', 'projection' }

def handle_catalog_create_dataset(api_url, args):
  data = {}
  params = parse_arguments(args, "catalog create-dataset", [])
  data['owner'] = getpass.getuser()
  data['db'] = get_parameter(params, 'db', optional=True)
  data['name'] = get_parameter(params, 'name', optional=True)
  data['hive_ql'] = get_parameter(params, 'hiveql', optional=True)
  data['base_dataset'] = get_parameter(params, 'base_dataset', optional=True)
  data['projection'] = get_parameter(params, 'projection', optional=True)
  data['filters'] = get_parameter(params, 'filters', optional=True)

  if len(params) != 0:
    print_catalog_help()
    error("catalog create-dataset: invalid argument(s): " + str(params.keys()))

  put_request(
      api_url + "datasets", "unable to create dataset", json.dumps(data))
  print("Dataset created.")

def handle_catalog_delete_dataset(api_url, args):
  params = parse_arguments(args, "catalog delete-dataset", [])
  db = get_parameter(params, 'db', optional=True)
  name = get_parameter(params, 'dataset', optional=True)

  if len(params) != 0:
    print_catalog_help()
    error("catalog delete-dataset: invalid argument(s): " + str(params.keys()))

  if db is not None:
    name = db + "." + name

  delete_request(api_url + "datasets/" + name, "unable to delete dataset")
  print("Dataset deleted.")

def handle_catalog_permissions(api_url, args):
  params = parse_arguments(args, "catalog permissions", [])
  db = get_parameter(params, 'db', optional=True)
  filter = get_parameter(params, 'filter', optional=True)
  users = get_parameter(params, 'users_groups', optional=True)
  detail = get_parameter(params, 'detail', optional=True)
  if db is None:
    db = 'default'

  if len(params) != 0:
    print_catalog_help()
    error("catalog permissions: invalid argument(s): " + str(params.keys()))

  args = {}
  args['db'] = db
  if filter is not None:
    args['filter'] = filter
  if users is not None:
    args['users_or_groups'] = users

  result_json = post_request(
    api_url + "permissions", "unable to get permissions", args).json()
  if detail is None:
    # Not viewing detailed view, filter out the detail only fields
    result_json = filter_json_keys(result_json, CATALOG_PERMISSIONS_DEFAULT_KEYS)
  if not result_json:
    print("No access permissions or no catalog objects.")
  else:
    print(tabulate(result_json, headers="keys"))

def handle_catalog_describe(api_url, args):
  params = parse_arguments(args, "catalog describe", ['dataset'])
  db = get_parameter(params, 'db', optional=True)
  dataset = get_parameter(params, 'dataset')
  if db is None:
    db = 'default'

  if len(params) != 0:
    print_catalog_help()
    error("catalog describe: invalid argument(s): " + str(params.keys()))

  url = api_url + "datasets/" + db + "." + dataset
  json_result = get_request(url, "unable to get dataset")
  print(json.dumps(json_result, indent=4))

def handle_catalog_list(api_url, args):
  params = parse_arguments(args, "catalog datasets list", [])
  db = get_parameter(params, 'db', optional=True)
  filter = get_parameter(params, 'filter', optional=True)
  detail = get_parameter(params, 'detail', optional=True)
  if db is None:
    db = 'default'

  if len(params) != 0:
    print_catalog_help()
    error("catalog list: invalid argument(s): " + str(params.keys()))

  args = {}
  args['db'] = db
  if filter is not None:
    args['filter'] = filter

  result_json = post_request(api_url + "datasets", "unable to list catalog", args).json()
  if detail is None:
    # Not viewing detailed view, filter out the detail only fields
    result_json = filter_json_keys(result_json, CATALOG_LIST_DEFAULT_KEYS)
  if not result_json:
    print("No catalog objects.")
  else:
    print(tabulate(result_json, headers="keys"))

def handle_catalog_grant_access(api_url, args):
  data = {}
  params = parse_arguments(args, "catalog grant-access", ['dataset', 'users_groups'])
  data['owner'] = getpass.getuser()
  data['users'] = get_parameter(params, 'users_groups')
  data['dataset'] = get_parameter(params, 'dataset')
  data['db'] = get_parameter(params, 'db', optional=True)
  data['projection'] = get_parameter(params, 'projection', optional=True)
  data['filters'] = get_parameter(params, 'filters', optional=True)

  if len(params) != 0:
    print_catalog_help()
    error("catalog grant-access: invalid argument(s): " + str(params.keys()))

  put_request(
      api_url + "grant-policy", "unable to grant access", json.dumps(data))
  print("Access granted.")

def handle_catalog_revoke_access(api_url, args):
  data = {}
  params = parse_arguments(args, "catalog revoke-access", ['dataset', 'users_groups'])
  data['owner'] = getpass.getuser()
  data['users'] = get_parameter(params, 'users_groups')
  data['dataset'] = get_parameter(params, 'dataset')
  data['db'] = get_parameter(params, 'db', optional=True)

  if len(params) != 0:
    print_catalog_help()
    error("catalog revoke-access: invalid argument(s): " + str(params.keys()))

  put_request(
      api_url + "revoke-policy", "unable to revoke access", json.dumps(data))
  print("Access revoked. This can take a few seconds to be refreshed.")

def handle_catalog(configs, args):
  if len(args) == 1:
    error("usage: cerebro_cli [options] catalog <subcommand> [parameters]\n" +\
        get_catalog_commands())

  cmd = args[1]
  if cmd == "help":
    print_catalog_help()
    return

  if 'catalog_hostport' not in configs:
    print_catalog_help()
    error("Catalog hostport not specified.")

  api_url = "http://" + configs['catalog_hostport'] + "/api/"
  if cmd == "status":
    print(get_request(api_url + "health", "unable to get health")['health'])
  elif cmd == 'create-dataset':
    handle_catalog_create_dataset(api_url, args)
  elif cmd == 'delete-dataset':
    handle_catalog_delete_dataset(api_url, args)
  elif cmd == 'grant-access':
    handle_catalog_grant_access(api_url, args)
  elif cmd == 'revoke-access':
    handle_catalog_revoke_access(api_url, args)
  elif cmd == 'describe':
    handle_catalog_describe(api_url, args)
  elif cmd == 'list':
    handle_catalog_list(api_url, args)
  elif cmd == 'permissions':
    handle_catalog_permissions(api_url, args)
  else:
    error("catalog: invalid subcommand '" + cmd + "'.\n" +
        get_catalog_commands())

#
# Login Commands
#
def print_login_help():
  print('''
login: Provide the user/password to generate a token. The token can be persisted in
       multiple ways to not require logging in each time. This command can also be
       used to generate multiple tokens.

       --persist: Persist the credentials to ~/.cerebro
''')

def handle_login(api_url, args):
  if len(args) == 2 and args[1] == "help":
    print_login_help()
    sys.exit(0)

  params = parse_arguments(args, 'login', None, first_idx=1)
  persist = get_parameter(params, 'persist', optional=True)

  if len(params) != 0:
    print_login_help()
    error("login: invalid argument(s): " + str(params.keys()))

  if persist is not None and persist != "":
    print_login_help()
    error("login: invalid persist mode: " + persist)

  user = input("user [%s]: " % getpass.getuser())
  if not user:
    user = getpass.getuser()
  password = getpass.getpass("password: ")

  data = json.dumps({"user": user, "password": password})
  response = put_request(api_url + "tokens", "unable to create token", data)
  token = response.json()

  print("Generated token: " + token["token"])
  if persist is not None:
    write_config_file(CREDENTIALS_FILE, token)
  else:
    print("To save the credentials, login with '--persist'")

#
# Status Commands
#
def get_status(api_url):
  try:
    response = requests.get(api_url + "system/status")
    if response.status_code == STATUS_OK:
      return True, response.text
    else:
      return False, "Unavailable"
  except requests.exceptions.RequestException:
    return False, "Unavailable"

def handle_status(api_url, args):
  if len(args) == 2:
    if args[1] == "help":
      print('status help:')
      print('    Returns the status of the deployment manager.')
      sys.exit(0)
    else:
      error("status: invalid subcommand '" + args[1] + "'.")
  available, status = get_status(api_url)
  if not available:
    print("Service unavailable")
  else:
    print("Service available. Status: " + status)

#
# System commands
#
def get_system_commands():
  return '''
valid subcommands are:
  canary
  info
  install
  update
'''

def print_system_help():
  print('''system subcommands:
    system info: Returns information about the deployment manager.
        --detail: [Optional, Default=False] Returns all the fields.
        --ignoreTransient: [Optional, Default=False] Ignore fields that are transient.
    system canary: Runs a canary if the service canary is enabled.
    system install: Installs the deployment manager.
        --adminUser: Name of the initial admin user.
        --loggingDir: Directory for logging.
        --awsAccessKey: aws key for deployment manager. Used to store deployment manager
            internal state.
        --awsSecretKey: aws secret for deployment manager. Used to store deployment
            manager internal state.
    system update: Updates system wide configs
        --authenticationEnabled: [Boolean] Whether or not to enable authenciation.
        --aclsEnabled: [Boolean] Whether or not to enable ACLs.
        --maxClusterSize: [Int] Max size of any cluster.
        --tokenDurationSec: [Int] Duration of granted tokens.
        --maxHeartBeatFailures: [Int] Number of consecutive heartbeat failures before
            a service is marked unhealthy.
        --loggingDir: Directory for logging.
        --versionConfigFile: File storing version configuration.
        --awsAccessKey: AWS credentials for deployment manager.
        --awsSecretKey: AWS credentials for deployment manager.''')

def handle_system_canary(api_url, args):
  info = get_request(api_url + "system/canary", "unable to get request canary")
  print(json.dumps(info['status'], indent=4))

def handle_system_info(api_url, args):
  params = parse_arguments(args, 'system info', [])
  detail = get_parameter(params, 'detail', optional=True)
  ignore_transient = get_parameter(params, 'ignoreTransient', optional=True)

  if len(params) != 0:
    print_system_help()
    error("system info: invalid argument(s): " + str(params.keys()))

  info = get_request(api_url + "system", "unable to get system info")
  if ignore_transient is not None:
    info["startTime"] = ""
    del info["buildHash"]
    del info["buildTime"]
    del info["upTime"]

  if detail is None:
    print("Status: " + info["status"])
    print("Version: " + info["version"])
    print("Start Time: " + info["startTime"])
    print("Authentication Enabled: " + str(info["authenticationEnabled"]))
    print("Acls Enabled: " + str(info["aclsEnabled"]))
  else:
    print(json.dumps(info, indent=4))

def handle_system_install(api_url, args):
  params = parse_arguments(args, 'system install',
      ['adminUser', 'loggingDir', 'awsAccessKey', 'awsSecretKey'])

  request = {}
  request['adminUser'] = get_parameter(params, 'adminUser')
  request['loggingDir'] = get_parameter(params, 'loggingDir')
  request['awsAccessKey'] = get_parameter(params, 'awsAccessKey')
  request['awsSecretKey'] = get_parameter(params, 'awsSecretKey')
  if len(params) != 0:
    print_system_help()
    error("system install: invalid argument(s): " + str(params.keys()))

  available, status = get_status(api_url)
  if not available:
    error("system: install: unable to reach deployment manager")
  if status != "Uninstalled":
    error("system: install: system already installed, cannot reinstall")

  put_request(api_url + "system", 'unable to install', json.dumps(request))
  print("Installing deployment manager.")

def handle_system_update(api_url, args):
  ensure_token_set()
  params = parse_arguments(args, 'system update', [])
  if len(params) == 0:
    error("system update: must update at least one configuration.")

  request = create_request()
  request['authenticationEnabled'] = get_parameter(
      params, 'authenticationEnabled', optional=True)
  request['aclsEnabled'] = get_parameter(
      params, 'aclsEnabled', optional=True)
  request['maxClusterSize'] = get_parameter(
      params, 'maxClusterSize', optional=True)
  request['tokenDurationSec'] = get_parameter(
      params, 'tokenDurationSec', optional=True)
  request['maxHeartBeatFailures'] = get_parameter(
      params, 'maxHeartBeatFailures', optional=True)
  request['loggingDir'] = get_parameter(params, 'loggingDir', optional=True)
  request['versionConfigFile'] = get_parameter(
      params, 'versionConfigFile', optional=True)
  request['awsAccessKey'] = get_parameter(
      params, 'awsAccessKey', optional=True)
  request['awsSecretKey'] = get_parameter(
      params, 'awsSecretKey', optional=True)

  if len(params) != 0:
    print_system_help()
    error("system update: invalid argument(s): " + str(params.keys()))

  post_request(api_url + "system", 'unable to update deployment manager', request)
  print("Deployment manager updated.")

def handle_system(api_url, args):
  if len(args) == 1:
    error("usage: cerebro_cli [options] system <subcommand> [parameters]\n" +\
        get_system_commands())

  cmd = args[1]
  if cmd == "help":
    print_system_help()
    return

  if cmd == "canary":
    handle_system_canary(api_url, args)
  elif cmd == "info":
    handle_system_info(api_url, args)
  elif cmd == "install":
    handle_system_install(api_url, args)
  elif cmd == "update":
    handle_system_update(api_url, args)
  else:
    error("system: invalid subcommand '" + cmd + "'.\n" + get_system_commands())

#
# Token commands
#
def get_tokens_commands():
  return '''
valid subcommands are:
  delete
  list
'''

def print_tokens_help():
  print('''tokens subcommands:
    tokens delete: deletes an existing token.
      --token: token to delete
    tokens list: Returns all the tokens (visible to this user).''')

def list_tokens(api_url, args):
  return post_request(api_url + "tokens", 'unable to list tokens').json()

def delete_token(api_url, args):
  params = parse_arguments(args, 'token delete', ['token'])
  token = get_parameter(params, "token")
  if len(params) != 0:
    print_tokens_help()
    error("tokens create: invalid argument(s): " + str(params.keys()))

  post_request(api_url + "tokens/" + token + "/delete", "unable to delete token")
  print("Deleted token: " + token + ".")

def handle_tokens(api_url, args):
  if len(args) == 1:
    error("usage: cerebro_cli [options] tokens <subcommand> [parameters]\n" +\
        get_tokens_commands())

  cmd = args[1]
  if cmd == "help":
    print_tokens_help()
    return

  if cmd == "delete":
    delete_token(api_url, args)
  elif cmd == "list":
    tokens_json = list_tokens(api_url, args)
    print(tabulate(tokens_json, headers="keys"))
  else:
    error("tokens: invalid subcommand '" + cmd + "'.\n" + get_tokens_commands())

#
# User commands
#
def get_users_commands():
  return '''
valid subcommands are:
  add
  list
  remove
'''

def print_users_help():
  print('''users subcommands:
    users list: Returns the users in the system.
    users add: Adds a new user to the system.
        --username: Name of the new user.
        --user_email: Email of the new user.
    users remove: Removes a user from the system.
        --user: ID/username of the user to remove.''')

def list_users(api_url, args):
  return post_request(api_url + "users", "unable to list users").json()

def add_user(api_url, args):
  params = parse_arguments(args, 'users add', ['user', 'email'])
  user = get_parameter(params, "user")
  email = get_parameter(params, "email")

  if len(params) != 0:
    print_users_help()
    error("users add: invalid argument(s): " + str(params.keys()))

  data = create_request()
  data['userName'] = user
  data['email'] = email
  response = put_request(api_url + "users", 'unable to add user', json.dumps(data))
  created_id = response.text
  print("Added user '" + user + "' (id=" + created_id + ").")

def remove_user(api_url, args):
  params = parse_arguments(args, 'users remove', ['user'])
  user = get_parameter(params, 'user')

  if len(params) != 0:
    print_users_help()
    error("users remove: invalid argument(s): " + str(params.keys()))

  post_request(api_url + "users/" + user + "/delete", "unable to remove user")
  print("Removed user: " + user + ".")

def handle_users(api_url, args):
  if len(args) == 1:
    error("usage: cerebro_cli [options] users <subcommand> [parameters]\n" +\
        get_users_commands())

  cmd = args[1]
  if cmd == "help":
    print_users_help()
    return

  if cmd == "add":
    add_user(api_url, args)
  elif cmd == "list":
    users_json = list_users(api_url, args)
    print(tabulate(users_json, headers="keys"))
  elif cmd == "remove":
    remove_user(api_url, args)
  else:
    error("users: invalid subcommand '" + cmd + "'.\n" + get_users_commands())

def handle_configure(args, original_configs):
  config = original_configs
  if config is None:
    config = {}
  if len(args) == 0:
    error("usage: cerebro_cli configure [--config1=v1] [--config2=v2]")

  params = parse_arguments(args, 'configure ', [], first_idx=1)
  server = get_parameter(params, "server", optional=True)
  userName = get_parameter(params, "userName", optional=True)
  token = get_parameter(params, "token", optional=True)

  if len(params) != 0:
    error("configure: unrecognized config(s): " + str(params.keys()))

  if server is not None:
    config["server"] = server

  write_config_file(CONFIGS_FILE, config)

# Augments OptionParser to ignore unknown options. We'll use OptionParser for
# general cli arguments and manual parsing for each command.
class PassThroughOptionParser(OptionParser):
  def _process_long_opt(self, rargs, values):
    try:
      OptionParser._process_long_opt(self, rargs, values)
    except BadOptionError as err:
      self.largs.append(err.opt_str)

  def _process_short_opts(self, rargs, values):
    try:
      OptionParser._process_short_opts(self, rargs, values)
    except BadOptionError as err:
      self.largs.append(err.opt_str)

def main():
  parser = PassThroughOptionParser()
  parser.add_option("-s", type="string", dest="server", default="",
                    help="Host:port of the server to connect to.")
  parser.add_option("--login_user", type="string", dest="user", default="",
                    help="User to run as.")
  parser.add_option("--login_token", type="string", dest="token", default="",
                    help="Token of user.")
  parser.add_option("--catalog-hostpost", type="string", dest="catalog_hostport",
                    default="", help="Catalog address to connect to.")
  options, args = parser.parse_args()

  # Load configs
  configs = read_config_file(CONFIGS_FILE, "Invalid configs file")

  # Resolve the server location.
  server = "localhost:8080"
  if len(options.server) != 0:
    server = options.server
  elif configs is not None and "server" in configs:
    server = configs["server"]
  if ':' not in server:
    server += ':8080'

  if options.catalog_hostport:
    configs['catalog_hostport'] = options.catalog_hostport

  api_url = "http://" + server + "/api/"

  if len(args) == 0:
    print_usage()
    error("too few arguments")

  cmd = args[0]
  if cmd == "commands":
    print(get_commands())
    sys.exit(0)
  elif cmd == "status":
    handle_status(api_url, args)
    sys.exit(0)
  elif cmd == "configure":
    handle_configure(args, configs)
    sys.exit(0)

  try:
    # Commands that don't require credentials to be set.
    if cmd == "help":
      handle_help()
      sys.exit(0)
    elif cmd == "catalog":
      handle_catalog(configs, args)
      sys.exit(0)
    elif cmd == "login":
      handle_login(api_url, args)
      sys.exit(0)
    elif cmd == "system":
      init_user_token(options)
      handle_system(api_url, args)
      sys.exit(0)
    else:
      init_user_token(options)
      ensure_token_set()

    # user/token must be set for the remaining commands.
    assert USER is not None
    assert TOKEN is not None

    if cmd == "acls":
      handle_acls(api_url, args)
    elif cmd == "clusters":
      handle_clusters(api_url, args)
    elif cmd == "environments":
      handle_environments(api_url, args)
    elif cmd == "tokens":
      handle_tokens(api_url, args)
    elif cmd == "users":
      handle_users(api_url, args)
    else:
      print_usage()
      print('cerebro_cli error: Invalid command. valid commands are:')
      print(get_commands())
      sys.exit(1)
  except requests.exceptions.RequestException:
    error("unable to connect to server: " + server)

if __name__ == '__main__':
  sys.exit(main())
